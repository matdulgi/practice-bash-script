# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* search
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh
* ./search:
* README.md


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# search


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# README.md


# file list
* convert_to_MD
* convert_to_md.sh
* gen_urls.sh
* practice
* search
* ./convert_to_MD:
* convert_to_md.sh
* ./practice:
* README.md
* aftermodifsTest
* argumentTest.sh
* arithmeticTest.sh
* commandSubstitutionTest.sh
* default.sh
* directorycheck.sh
* evalTest.sh
* fileParameterTest.sh
* first.sh
* forTest.sh
* getFileListTest.sh
* getPathTest.sh
* ifsTest_arr.sh
* ifsTest_parameter.sh
* listtest.sh
* parameterTest.sh
* quoting.sh
* readTest.sh
* reservedWordTest.sh
* shebangTest.sh
* shellHierarchyTest.sh
* sliceArrTest.sh
* stringTest.sh
* subshelltest.sh
* substitutionTest_eval.sh
* tabCompletionTest.sh
* varInRegExTest.sh
* varTest.sh
* verboseErrorTest.sh
* zshTest.sh
* ./search:
* README.md


# convert_to_MD


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


# gen_urls.sh
#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O


# practice


# search


# convert_to_md.sh
#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T


# README.md
# shellScriptPractice


# aftermodifsTest
#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5


# argumentTest.sh
#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}


# arithmeticTest.sh
#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i



# commandSubstitutionTest.sh
#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


# default.sh


# directorycheck.sh
#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc


# evalTest.sh
#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b



# fileParameterTest.sh
#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir


# first.sh
#!/bin/bash

echo "echoecho"
printf "pfpf"


# forTest.sh
#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done


# getFileListTest.sh
#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)



# getPathTest.sh
#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)


# ifsTest_arr.sh
#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs



# ifsTest_parameter.sh
#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"


# listtest.sh
#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}


# parameterTest.sh
echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"


# quoting.sh
#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'



# readTest.sh
#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp


# reservedWordTest.sh
echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"


# shebangTest.sh
#!/ust/bin/env python
echo go~~$TESTVAR


# shellHierarchyTest.sh
#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')




# sliceArrTest.sh
#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS


# stringTest.sh
#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}



# subshelltest.sh
#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)


# substitutionTest_eval.sh
#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute



# tabCompletionTest.sh
#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest


# varInRegExTest.sh
#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation




# varTest.sh
#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar




# verboseErrorTest.sh
#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done


# zshTest.sh
#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# README.md



#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T

#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O



#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T

# shellScriptPractice

#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5

#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}

#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i


#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc

#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b


#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir

#!/bin/bash

echo "echoecho"
printf "pfpf"

#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done

#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)


#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)

#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs


#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"

#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}

echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"

#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'


#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp

echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"

#!/ust/bin/env python
echo go~~$TESTVAR

#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')



#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS

#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}


#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)

#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute


#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest

#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation



#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar



#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done

#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# 01/21
* move to own directory
* remove automatic initializing pass to pwd (requires pass argument)

# requires (difference to any other tool)
* get file's name and contents by hierarchy constructor
* 

# todo
* add tree


current version use ls -R

ls -R comman shows the result next way

```
./dir1:
file1
file2
file3
file4
```

###alternative way



#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T

#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O



#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}/$i
    echo file : $file
    sed -i "" 's/^\s*ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^\s*ㅁ/### /' ${top}$i > /dev/null
#    sed  's/^\s*ㅇ/# /' ${top}/$i
#    sed  's/^\s*ㅁ/### /' ${top}/$i
  fi
done


IFS=$IFS_T

# shellScriptPractice

#!/bin/bash


echo v1 : $1
echo v2 : $2
echo v3 : $3
echo v4 : $4
echo v5 : $5

#!/bin/bash

echo all argument : $@
argarr=$*
argarr2=($*)
echo argarr@ : ${argarr[@]}
echo argarr1 : ${argarr[1]}
echo argarr2 : ${argarr[2]}
echo argarr2@ : ${argarr2[@]}
echo argarr21 : ${argarr2[1]}
echo argarr22 : ${argarr2[2]}

for((i=1; i<$#; i++));do
    echo arg $i : ${argarr[$i]}
done




echo '$1':$1
echo '$2':$2
echo '$[1]':$[1]
echo '$[2]':$[2]
echo '${1}':${1}
echo '${2}':${2}

#!/bin/bash



echo $(( 1 + 4 ))
i=5
(( ++i ))
echo i : $i


#!/bin/bash

lsal=`ls -al`
echo $lsal

echo

lsal=$(ls -al)
echo $lsal


echo
echo doule command substitution test
var1=hello
var2=$var1

echo var1 : $var1
echo var2 : $var2



echo
echo CS for arr
idx=3
a=aaa
b=bbb
c=ccc
d=ddd
e=eee
arr=($a $b $c $d $e)
echo arr[] $[iex]: ${arr[$idx]}


echo    
echo CS calculate test
calval=5
echo $calval-5
#result : 5-5  >  print as string


#!/bin/bash

function checkIsDir {
if [ -d $1 ]; then
  echo its directory
else
  echo its not directory
fi
}

checkIsDir ~/.vim
checkIsDir ~/.vimrc

#!/bin/bash.sh

var1=testValll
var2=var1
echo $var2

echo ${!var2}




#eval echo \$$b


#!/bin/bash
testDir=/user/yura/
checkDir(){
    if [ -d ${testDir} ]; then 
        echo "true"
        else echo "false"
    fi
    if [ -e ${testFile374} ]; then 
        echo "true"
        else echo "false"
    fi
}
checkDir

#!/bin/bash

echo "echoecho"
printf "pfpf"

#!/bin/bash

echo test for loop with list
list=(1 2 3)
for i in ${list[@]}; do
    echo $i
done

echo test for loop with range formed list
for i in {1..3}; do
    echo $i
done
echo test for loop with range formed list 001
for i in {001..3}; do
    echo $i
done


echo test for loop with three-param expression 
for ((i=0; i<3; i++))
do
    echo three param expressoin
done



echo test for loop with range formed list with var
#doesnt work with $max
max=4
echo max : $max
for ((i=1; i<=$max; i++))
do 
    echo formed list with var test
done


echo for loop with curly braces
for i in (1..3); do
    echo with no curly braces
done

#!/bin/bash

inputFile=""
outputFile=""
destHost=""
dirDepth=0

help(){
    echo "USAGE" 
    echo "  getFileList -i [inputFile] [-d destHost]"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master"
    echo "  ex) getFileList -i hdfs://pc00m0002.pcn0c01.hcloud.io:8020/user/bdc_master -d hdfs://pc00m0001.pcn0c01.hcloue.io:8020"
    echo ""
    echo "OPTIONS"
    echo "  -i    input file's FQDN"
    echo "  -D    destinaon host's hostname"
    echo "  -d    directory depth for copy"
}


while getopts "i:d:D:h" opt
do
    case $opt in
        i)
            inputFile=$OPTARG
            echo inputFile : $inputFile
            ;;
        d)
            dirDepth=$OPTARG
            echo dirDepth : $dirDepth
            if [$dirDepth lt 1];then
                echo "directory depth must be grater then 0"
                exit
            ;;
        D)
            destHost=$OPTARG
            echo destHost : $destHost
            ;;
        h)
            help
            ;;
    esac        
done

list=$(ls -al $inputFile)


#!/bin/bash

#get script file path
echo file path : $( cd $(dirname $0) && pwd)

#!/bin/bash

str1="a b c d e"
str2="a:b:c:d:e"
str3="a^b^c^d^e"
echo $str1
echo $str2
echo $str3

echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done

echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done


echo
echo change IFS to :
old_ifs=$IFS
IFS=":;^"
echo

echo $str1
echo $str2
echo str1 separate Test
for tmp in $str1; do
    echo $tmp
done
echo str2 separate Test
for tmp in $str2; do
    echo $tmp
done

echo str3 separate Test
str3="a^b^c^d^e"
echo $str3
for tmp in $str3; do
    echo $tmp
done

IFS=$old_ifs


#!/bin/bash

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5

IFS=":^"
echo after mod IFS

echo $*
echo $#
echo $1
echo $2
echo $3
echo $4
echo $5
IFS=" \t\n"

#!/bin/bash

list1=(1 2 3 4 5)
list2=({3..7})

#cannot get all element with tlist
echo list1 ${tist1[@]}
echo list2 ${list2[@]}

for i in ${list1[@]}; do
echo list1 loop test
done



#list with for loop expression
list3={(i=1; i<5; i++)}

echo "scriptname ${0}"
echo "quantity ${#}"
echo "values1* ${*}"
echo "values2@ ${@}"
echo "1th ${1}"
echo "2th ${2}"
echo "3th ${3}"

#!/bin/bash

echo weak quoting
echo "$hello"

echo strong quoting
echo '$hello'


#!/bin/bash

read -p 'type anything : ' str
result=$str
echo $result
#echo $result > readResult.tmp

echo "HOME ${HOME}"
echo "PATH ${PATH}"
echo "LANG ${LANG}"
echo "UID ${UID}"
echo "SHELL ${SHELL}"
echo "USER ${USER}"
echo "FUNCNAME ${FUNCNAME}"
echo "TERM ${TERM}"
echo "JAVA_HOME ${JAVA_HOME}"
echo "CATALINA_HOME ${CATALINA_HOME}"

#!/ust/bin/env python
echo go~~$TESTVAR

#/bin/bash

echo current shell
ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}'

echo
echo sub shell
(ps -ef | grep -e bash -e "\ssh\s" | awk '{print $1" "$2" "$3" "$8}')



#!/usr/bin/env bash

# replacing to zero string is not work to split
arr=( 1 2 3 4 5 ) 
echo ${arr[@]}
arr[0]=""
echo ${arr[@]}

echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}


# to split array, it could followed way
arr=("${arr[@]:2}")
echo ${arr[@]}
echo arr[0] : ${arr[0]}
echo arr[1] : ${arr[1]}

# how about string
str="1 2 3 4 5 "
echo str[0] : ${str[0]}
str[0]=''
echo $str

# Parenthesis make string to array by IFS

#get length by #
str1=dear my friend
echo str1:$str1
echo length:${#str1}


#!/bin/bash

(
    while [ 1 -eq 1 ]; do
        ((a++))
    done
)

#!/bin/bash

a=hello
b=$a

echo $b



x=hello
y=x

echo $$y
#it parsed $$ fitst, $$ is parsed to own value 91399, result is 91399z


eval 'echo $'$y''
eval 'echo $$y'

#eval ignore quote, substitute


#!/usr/bin/env bash
completion -W "aaa bbb ccc ddd" hello
completion -W "aaa bbb ccc ddd" tabCompletionTest

#!/bin/bash

word=var

echo  - it prints only start with 'var'
ls -al | awk '{print $9}' | grep '^var'
echo

echo  - how is will it go with param substitution with regex
ls -al | awk '{print $9}' | grep '^${word}'
echo word='^${word}'
echo param substitution won't work with single quotation '

echo 
echo - how about with double quotation
ls -al | awk "{print $9}" | grep "^${word}"
echo "${word}"
echo awk do not work woth double quotation
echo if it needs to use prarm Sub in RegEx, it needs to double quotation. but some commands require single quotation for those argument
so, it needs the way how do put paramSub in RegEs with single quotation



#!/bin/bash 
set -x
va=va
var=var
varvar=var2


echo $varva$varvar



#!/bin/bash

while getopts ":ab:c:" opt; do
    echo OPTIND : $OPTIND
    case $opt in
        a)
            echo option a opt : $opt  optarg : $OPTARG 
            ;;
        b)
            echo option b opt : $opt  optarg : $OPTARG 
            ;;
        c)
            echo option c opt : $opt  optarg : $OPTARG
            ;;
        ?)
            echo option ? opt : $opt  optarg : $OPTARG
            ;;
        :)
            echo option : opt : $opt  optarg : $OPTARG 
            ;;
    esac
done

#!/bin/zsh

#execute this script with zsh environment

#zsh provided pointer of variable as P Parameter Expanstion 
a="hello"
b="a"
print ${(P)b}



unix.stackexchange.com/questions/68035/foo-and-zsh


# 01/21
* move to own directory
* remove automatic initializing pass to pwd (requires pass argument)

# requires (difference to any other tool)
* get file's name and contents by hierarchy constructor
* 

# todo
* add tree


current version use ls -R

ls -R comman shows the result next way

```
./dir1:
file1
file2
file3
file4
```

###alternative way



#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T

#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O




#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T

#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O




#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T

#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O



#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T


































#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T

#!/bin/bash

IFS_O=$IFS
IFS=$'\n'
dir=$1

if [ -z $dir ]; then
  dir=$(pwd)
fi
echo directory : $dir

#arr=( $(ls -R) )
for i in $(ls -R); do
  if [[ $i =~ : ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  if [[ $i == *".url" ]] ; then
    echo i: $i
    url=$(cat $top$i | grep -v 'InternetShortcut' | sed 's/URL=//')
#    echo \* $i >> ${top}_url
#    echo $url >> ${top}_url
    echo \* $i >> urls
    echo $url >> urls
  fi
done

IFS=$IFS_O



#!/usr/bin/env bash

IFS_T=$IFS
IFS=$'\n'

#for i in $(ls */*); do
#for i in $(ls **/*); do
#  sed -i "" 's/^\s*ㅇ/# /' $i
#  sed -i "" 's/^\s*ㅁ/### /' $i
#done


arr=( $(ls -R ) )

for i in ${arr[@]}; do
  echo i : $i
  if [[ $i == *":" ]]; then 
    top=$( echo $i | sed 's/:/\//')
    echo top : $top
    continue
  fi
  
# in macox, sed need backup option ""
  if [[ './'$i != $0 ]]; then
    file=${top}$i
    echo file : $file
    sed -i "" 's/^ *ㅇ/# /' ${top}$i > /dev/null
    sed -i "" 's/^ *ㅁ/### /' ${top}$i > /dev/null
  fi
done


IFS=$IFS_T

































